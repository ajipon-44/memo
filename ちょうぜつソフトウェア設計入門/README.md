# ちょうぜつソフトウェア設計入門

## 第 1 章 クリーンアーキテクチャ

アーキテクチャ ... 何をどこに配置するかを決めるもの

アーキテクチャはソフトウェアの動作のパフォーマンスを向上させない、**ソフトウェアを開発するパフォーマンス**を向上させるもの

### 汚い設計はなぜ生産性を落とすか

コードの意味を認識・理解するのに時間がかかるから

汚いコードとは
・まとまりが悪くあちこちに変更しないといけないので苦労する
・同じところに意味の違うものが混ざっていて壊れやすい

### 凝集度

関係の強いもの同士だけが集まっていることを表す指標

### 依存の向きと安定度

密結合の問題点 ... 変更に対して **無条件** に動作を保証できなくなる

### 凝集度と結合度の違い

関心の分離をして、凝集度を高めていても、依存の仕方によっては 1 つの変更によって、芋づる式に変更が生じる可能性がある

**疎結合とは、モジュールのまとまり具合以外に、依存によるつながりも含んだ意味を持っている**

### 安定度とは

安定度とは ... コードの変わりにくさを表す度合い

モジュール間に一切のつながりをなくすことはできない
よって、**変更の影響を最小化すること**を目指したい、そのためには頻繁に変わるものに依存しないことが合理的

つまり、**依存するならコードの安定度が高いものに依存するべき**

安定度の高いコードの見分けかたは本質的か本質的でないか
本質的とは ... アプリケーションが成し遂げたい大目的に沿ったものかどうか

### どうすればクリーンになるのか

クリーンな設計の条件

1. ひとつの関心がひとつの箇所に閉じている（高凝集にする）
2. 利用する / されるの関係箇所を可能な限り減らす（疎結合にする）
3. できるだけ変更頻度の高い事情に依存しない（安定度の高いものに依存する）

<img src="/Users/yanaikeigo/Downloads/IMG_2992.jpg" alt="スクリーンショット 2024-11-10 2.41.40" style="zoom:30%;" />

### 1 層目「ドメインモデル」

円の最も内側の核となる部分
どんなニーズであっても必要なもの

**対象とする情報そのものに関する部分**

**プログラミング言語の文法、標準ライブラリ以外に依存しないように記述する**

安定度が最も高くなる箇所
**変わらないことだけを意図的に抽出して入れる**

### 2 層目「ユースケース」

ユーザが行いたい操作を表現するロジック

ユーザの要望によって変化する（ex. どのようなデータを引き出したいか、データのどのような項目をいつ書き換えたいか）

業務内容がドメインモデルなら、（効率の良し悪しは抜きに）**業務方法や操作手順をロジック化したところ**がユースケース

**ドメインモデル以外への依存がない**

### 3 層目「インターフェースアダプター」

コントローラやメインルーチンなどのエントリーポイント。
プレゼンテーションモデルなどもこの層に入る。

それぞれのユースケースを参照しつつう、入力から出力までのコンピュータの制御の流れを表現する

**ユースケースに依存する**

### 4 層目「インフラストラクチャ」

DB 接続やメール送信といった外部とのやりとりを担う部分

技術レイヤーに置くべきはデータの取得方法であって、いつ何件の取得を行うかの主導権は業務ロジックにあるべき

### 偏在するクリーンアーキテクチャ

クリーンアーキテクチャはあくまで層の分け方の話であり、どこに何を置くかはソフトウェアごとに異なる
どんな場合でも大まかに４つほどのグループに分けられそうだという話

フレームワークでもなければ、設計の答えでもない

## 第 2 章 パッケージ原則

### 再利用・リリース等価の原則（REP）

リリースされたものだけを再利用すること、再利用させたければリリースすること

チーム開発でいうリリースとは、main ブランチにマージされること

#### 別の人が作る機能を使いたいが、作り終わるまで待てないとき

再利用する箇所の単位を適切に分けてリリースを待つ
設計者（再利用される側を開発する人）に気を使わせて再利用する側に合わせるようにしてはいけない

### 全再利用の原則（CRP）

変更されたパッケージには「この変更は必要だけど、この変更はいらない」といった取捨選択はできない
分けるべきものは分けろ

なんらかのアップデートによって、機能改善と互換性のどちらかを取らないといけない状況にあるとき、それはアップデートの粒度が大きすぎる

最初は細かすぎるくらいで良い、後から繋げることは簡単だが、分けることは難しいので。

### 閉鎖性共通の原則（CCP）

１つの変更が必要なとき、可能な限り１つのパッケージだけを交換すれば済む形にすること

#### パッケージが閉じているとは

パッケージ内で 1 箇所でも変更すれば、パッケージのすべてのコードがなんらかの影響を受ける可能性がある
そうでないなら、互いに無関係なコードのグループが複数あることになり、全再利用の原則に違反する

良いパッケージは自身の責務が程よいサイズで自己完結している、これを**閉じている**という。

全再利用の原則では分け得るべき、閉鎖性共通の原則ではまとめるべきを推していたが、**責務とパッケージが１対１**になるようにすることがポイント

### 非循環依存関係の原則（ADP）

パッケージの依存が循環してはならない

２つのパッケージが相互依存すると、それらはセットで扱わなければいけなくなり、実質複数の責務を持った大きなコード群になる

クラス単位で循環依存するのは Java の標準ライブラリでも行われおり、問題なのはパッケージ間で循環依存が行われている状態

### 安定依存の原則（SDP）

パッケージの依存は常により安定したパッケージに向く

不安定に依存すると、依存先以上の安定さを求めることはできない
なぜなら依存先に変更があるたびに変更を加える必要があるから

### 安定度・抽象度等価の原則（SAP）

パッケージの安定度と抽象度には相関関係がある

抽象度の高さは以下の４つにどれだけ近いかで決まる

- 抽象クラスやインターフェースなど実装詳細を自身から排除したもの
- 上記のような詳細を持たないものだけに依存するロジック
- 固有の業務にも特的技術にも関係しない時刻や配列などの汎用概念とその操作
- プログライング言語そのものや言語標準ライブラリと同等レベルの業界標準

#### 依存先の選び方

1. 抽象的なもの
   1. 実装を持たないような抽象的なもの
2. 安定的なもの
   1. 誰の事情も受け付けない変わりようのない普遍的なもの（時刻や配列から最大値を抜き出すといった配列操作）
      1. こういったものであればサードパーティライブラリであろうが抽象的なものとみなされる

### アーキテクチャの外側

クリーンアーキテクチャの外にあるものは DB そのものであったり、フレームワークライブラリ

**クリーンアーキテクチャにおいて、不安定なのはアーキテクチャ内の最外殻**であり、外の世界ではない

外部のソフトウェアは開発対象とは異なる観点の安定抽象をもつ独立したアーキテクチャでできている

最外殻であるインフラストラクチャ層はインターフェースアダプター層と外部のソフトウェアの両方に依存するため、安定度が低くなる。

## 第 3 章 オブジェクト指向

## 第 4 章 UML（統一モデリング言語）

## 第 5 章 オブジェクト指向原則 SOLID

## 第 6 章 テスト駆動開発

## 第 7 章 依存性注入

## 第 8 章 デザインパターン

## 第 9 章 アジャイル開発
