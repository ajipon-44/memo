# Java Basic
## Java
Java1.8 = Java8
Java9
Java10

## データ型
### プリミティブ型
- 数値型
  - "_"で見やすく区切り文字を入れることができる
    - 文頭、文末、記号の前後はNG

  - byte 型
    - 1 バイト
  - short 型
    - 2 バイト
  - int 型
    - 4 バイト
    - "0b"から始まると2進数
    - "0"から始まると8進数
    - "0x"から始まると16進数
  - long 型
    - 8 バイト

- 浮動小数点型
  - float 型
    - 4 バイト
    - 小数で渡した場合、デフォルトは double なのでキャストする必要がある
      - float f = 1.99f
    
  - double 型 (デフォルト)
    - 8 バイト
- 論理型
- 文字型
  - 2 バイト
  - シングルクォートで囲む
  - 文字列は文字の配列という扱いになる、ダブルクォートで囲む
  - 0~65535の数値(16進数4桁)の数値は扱える


### 参照型
- 配列型
  - Stringクラスを使うと値渡しになる
- オブジェクト型
- インターフェース型

## 初期化

ローカル変数は初期化が必要、クラスフィールドなどは初期化する必要がない

| 項目                   | ローカル変数                                           | クラスフィールド・静的変数                           |
| ---------------------- | ------------------------------------------------------ | ---------------------------------------------------- |
| **初期化の必要性**     | 必須（明示的に初期化が必要）                           | 必要なし（デフォルト値で自動初期化）                 |
| **利用範囲**           | メソッド内（狭いスコープ）<br />つまり参照回数が少ない | クラス全体（広いスコープ）<br />つまり参照回数が多い |
| **初期化漏れのリスク** | 低い（すぐに影響が分かる）                             | 高い（影響が広範囲に及ぶ）                           |
| **設計思想**           | 安全性よりも意図的なコードを書くことを重視             | 整合性と一貫性を優先                                 |



## String オブジェクト

イミュータブルな文字列のオブジェクト
再代入した際は参照が書きかわる（再代入しようとしている値が新しいメモリ空間を確保する）ので再代入可能

```java
String a = "aaa";
a = "aaaaa"; // これはOK
replace("a", "b"); // これはNG
a = replace("a", "b"); // これはOK
```

主なメソッド

- valueOf
  - Stringオブジェクトを生成する
  - String a = String.valueOf("aaa");
  - String a = new String("aaa"); と同義
- charAt
  - 文字列の中から、引数で与えられた数値の箇所を返す
  - String a = "abcde"; a.charAt(3);
    - dを返す
- indexOf
  - 引数が文字の場合
    - 与えられた文字の場所を返す
    - String a = "abcde"; a.indexOf(c);
      - 2を返す
  - 引数が文字列の場合
    - 与えられた文字列が始まる場所を返す、なければ -1 を返す
    - String a = "abcde"; a.indexOf(abcdef);
      - -1 を返す

## リテラル

プログラムに直に書かれた値のこと
プログラム実行時に変化しない値のこと

```java
// これの123
// 変数名にはアルファベットの他に、"$"と"_"が使用可
int i = 123;
```

### 数値セパレータ
現実世界で数値を3桁ごとにカンマで区切るように、プログラム内ではアンダースコアで区切ることができる。
```java
int i = 123_456;
```

### テキストブロック
複数行に渡る長い文字列を表記する記法
Java15からサポート
ダブルクォート3つで囲む
最初の3つのダブルクォートの直後に改行が必要
1番左にあるもの(文章の中身or最後のダブルクォート3つ)よりも右にあるインデントは文字列に影響を与える

```java
// 以下の場合、長い文字列2の前にインデントが表示される
String str = """
  長い文字列
　　長い文字列2
  """
```



## 型変換(キャスト)

型と型の間に互換性があるときに、型を変換することができる

### 拡大変換
int → doubleのように狭い型から広い型に変換すること。
暗黙的に行うことができる。
```java
int x = 100;
long y = x;

// float型であることを明示する「F」
// 型サフィックスと呼ばれる
float f = 12345.67F;
double d = f;
```

### 型サフィックス

```java
int x = 100;
// 以下はコンパイルエラー
// 整数リテラルはint型に利用されるため、int型の範囲内しか受け付けない
// 長い数値には"_"を途中で入れることができる
long y = 30_000_000_000;

// float型であることを明示する「L」で型サフィックスをする
// "_"は文頭、文末、記号の前後はNG
long y = 30_000_000_000F;
```

### 縮小変換
double → intのように広い型から狭い型に変換すること。
明示的に行う必要がある。

```java
int x = 100;
short y = x; // コンパイルエラー

int x = 100;
short y = (short) x;
```


## オーバーロード

### メソッドのシグネチャ

メソッドの名前、引数の数と型の総称
シグネチャが同じメソッドは複数定義できない

```java
// 以下の場合であれば、「doSomething, 引数のint、引数の数 1」がシグネチャ
void doSomething(int x)
```

### オーバーロード

シグネチャのうち、引数の数と型が異なるメソッド名が同じメソッドを定義することをオーバーロードという

```java
// メソッドのオーバーロードの例
void doSomething(int x)
void doSomething(int x, int y)
void doSomething(String str)
  
// コンストラクタのオーバーロード
Person() { ... }
Person(String name) { ... }
Person(int age) { ... }
```



## メモリ割り当て

### スタック領域

- 高速
- 関数のローカル変数など細かく変わるものが格納される
- プリミティブな値が格納される
  - サイズが固定であり、ローカル変数などでよく使われるから

### ヒープ領域

- 動的なサイズ確保
- GCや開発者による意図的なメモリ解放が必要
- クラスのインスタンスや参照型（配列、オブジェクト、インターフェース）が格納される
  - 多くの関数で使い回されたり、サイズが固定長でないから

### 静的領域（スタティック領域）

- クラスの情報やメソッドの情報などプログラム実行によって変化がないものが格納される

### ライフサイクル

クラスファイル
→クラスローダによってスタティック領域にクラス情報が格納される
→インスタンスが生成されるとヒープ領域に格納される
→参照されなくなるとGCで廃棄される

このような都合上、インスタンスからクラスファイルを参照することはできるが、逆はできない
なぜなら、クラスファイルからインスタンスを見ようとしても生成されているかが保証されないから



## スタティックなオブジェクト

### スタティックフィールド

クラスが直接保持する変数で、JREの中でただ一つだけ存在する
役割はグローバル変数的なもの

定義方法

```java
static データ型 フィールド名;
```

```java
class Person {
  static String name;
  static int age;
}
```

使用用途

- グローバル変数であるため、あまり多用するべきではない
- マルチスレッドなシステムでは更新処理が同時に起こる可能性も踏まえてReadOnlyな値にすべき

### スタティックメソッド

定義方法

```java
static 戻り値 メソッド名(型1 引数名1, 型2 引数名2, ...) {
}
```



## final 修飾子

#### クラスに付与する場合

継承を禁止する

#### メソッドに付与する場合

オーバーライドを禁止する

#### フィールドに付与する場合

値の再代入を禁止する
必ずフィールド宣言またはコンストラクタによって、一度だけ初期値を代入することというルールになる

```java
class Person {
  final String name;
  final int age;
  
  // コンストラクタが必ず必要になる
  Person(String name, int age){
    this.name = name;
    this.age = age;
  }
}
```

#### ローカル変数に付与する場合

値の再代入を禁止する

```java
final int x = 10;
// コンパイルエラー
x = 20;
```



## 定数

一度代入されたら変更されない変数

static 修飾子、final 修飾子、アクセス修飾子の 3 つを同時にフィールドに付与して宣言する

```java
public static final データ型 変数名 = 値;
```



## パッケージ

同一のクラスを複数作るための名前空間のようなもの
クラス名を階層構造に分類するための仕組み
ドメイン名とは異なり、最上位は一番左、右に行くに従って下位になる

FQCN（Fully Qualified Class Name: 完全修飾クラス名） ... パッケージ名＋クラス名
FQCNからパッケージ名を取り除いた部分 → クラス名または単純名

```java
package パッケージ名;
```



## オーバーライド

親クラスから継承したメソッドを上書きすること、以下の条件を満たす必要がある

- メソッド名が一致していること
- 引数の数とデータ型が一致していること（引数名は不一致でも問題なし）
- 戻り値のデータ型が一致している、またはその型の下位方向の型であること
- アクセス修飾子が一致しているか、親クラスよりも可視性が広いこと
- throws 句に指定可能なのは、親クラスの throws 句に指定された例外クラスと同じか、またはその型の下位方向の型であること

### リスコフの置換原則

「子クラスは親クラスと同様の使い方ができるべきである、サブクラスを親クラスとして扱える」という考え方

- 事前条件は継承先では弱くなるべきである
  - アクセス修飾子の制約が親クラスよりも強くなると、親クラスは呼び出せても子クラスは呼び出せないという状況が考えられてしまう
- 事後条件は継承先では強くなるべきである
  - 返り値の型が親クラスの上位方向であった場合、継承元の返り値で持っていた情報が継承先の返り値では存在しないという状況になってしまうから（基本的に、下位方向であればあるほど、具体性が上がり、持っている情報が多くなる）
- 不変条件は継承先でも同様であるべきである



## 抽象メソッド

メソッド宣言はしても中身を持たない空のメソッド

```java
abstract 戻り値の型 メソッド名(型1 引数1, ...);
```



## 抽象クラス

メンバとして、1つ以上の抽象メソッドを持つクラス
抽象メソッドを1つも持たないクラスは具象クラス

インスタンスの生成はできない
継承を前提としており、継承した具象クラスで抽象メソッドをオーバーライドする（コンパイラに強制される）

様々な具象クラスの共通実装を提供する
具象クラスの種類によって、異なる振る舞いは抽象メソッドとして定義し、実装は具象クラスに任せる

```java
abstract class クラス名 {
  ... フィールド ...
  ... コンストラクタ ...
  ... メソッド ...
  ... 抽象メソッド ...
}
```



## クラス型変数のキャスト

以下のような継承関係があったとする。

- Foo は Bar を子クラスとして持つ
- Bar は Qux と Buzz を子クラスとして持つ
- Qux は Hoge を子クラスとして持つ

Foo <- Bar <- Qux <- Hoge
             └── Baz

  クラス間のキャストには、互換性の観点から以下の 4 つのルールが存在する

- 親クラスへのキャストは可（例：Qux から Foo へのキャスト）、明示的に行う必要なし
- 一度上位クラスにキャストされた後、下位のクラスにダウンキャストは可、明示的に行う必要あり
- インスタンス生成元のクラスよりも下位に存在するクラスへのキャストは不可（例：Qux から Hoge へのキャスト）
  - ClassCastException
- 継承関係にないクラスへのキャストは不可（例：Qux から Baz へのキャスト）
  - ClassCastException

コンパイル時は型の同一性と継承関係を調べて互換性を確認

実行時には実態とキャスト先がアップキャストの関係か同一の型かを確認(ダウンキャストも結局インスタンスベースで見れば同一の型にはめているだけ)

### インスタンス判定

instanseof 演算子で互換性判定を行う
互換性がないキャストを行ってもコンパイルエラーにならず、実行時に例外が発生するので互換性判定が重要

```java
// 基本構文
変数名 instanseof クラス名
Foo foo = new Qux();
if (foo instanseof Foo) // true
if (foo instanseof Bar) // true
if (foo instanseof Baz) // false
if (foo instanseof Qux) // true
if (foo instanseof Hoge) // false
```

### コンパイルエラーと例外

コンパイラは変数の型を確認し、そのクラスを確認し、「extends」を見るので、そこに互換性が確認できるものがなければコンパイルエラーになる

例外（ClassCastException）は開発者が明示的にキャストしたが、実行時に互換性がなかったときに起こる

## 継承

継承関係にあるクラスにおいて、サブクラスのコンストラクタには暗黙的に最初に親クラスのコンストラクタが呼び出される

```java
class A {
  public A() {
    System.out.println("A");
  }
}

class B extends A {
  public B() {
    // ここに以下の親クラスのコンストラクタを呼ぶコードが隠れている
    // super();
    System.out.println("B");
  }
}

A a = new B();
// A
// B
B b = new B();
// A
// B
```

同じフィールドを宣言した時

- フィールドにアクセスするときは変数の型名に従う
- メソッドでアクセスするときはメソッドの宣言したクラスに従う

```java
public class A {
  int num;
  void print() {
    System.out.println(num);
  }
}

public class B extends A {
  int num;
}

A a = new A();
A b = new B();
System.out.println(a.num); // Aの方
System.out.println(b.num); // Aの方
a.print(); // Aの方
b.print(); // Aの方

// Bがprint関数をオーバーライドする
public class B extends A {
  int num;
  
  @Override
  void print() {
    System.out.println(num);
  }
}
b.print(); // Bの方

```





## 多態性（ポリモーフィズム）

同じ型でありながら、振る舞いが異なること

以下の例では、foo1 とfoo2 はともに Foo クラスでありながら、print メソッドによる振る舞いが異なる

```java
// Bar クラスと Bax クラスは Foo クラスを継承しているとする
// また、Foo クラスでは抽象メソッド print があるものとする
// Foo <- Bar
//   └── Baz

// foo1 は抽象メソッド print を System.out.println("Bar") とオーバーライド
Foo foo1 = new Bar();

// foo2 は抽象メソッド print を System.out.println("Buz") とオーバーライド
Foo foo2 = new Buz();

foo1.print
// Bar
foo2.print
// Buz
  
// ただし、親クラスで定義されていないメソッドを利用することは不可能
// BarとBuzでadd関数を実装したとする
// 以下のようにインスタンスを生成すると、変数の型が Foo であるため、 Foo に存在しない add 関数は扱えない
Foo foo1 = new Bar();
Foo foo2 = new Buz();

// このようにしたいのなら、Foo クラスで具象メソッドか抽象メソッドで add を定義し、オーバーライドする必要がある
foo1.add // コンパイルエラー
foo2.add // コンパイルエラー
```

## バインディング

バインディング ... プログラム内のメソッドの呼び出しとメソッドの実装を紐づける仕組み

- 静的バインディング
  - コンパイル時に実行
  - オーバーロードされたものを紐づける
  - 呼び出せるメソッドが決まる
- 動的バインディング
  - プログラム実行時に実行
  - オーバーライドされたものを紐づける
  - メソッドを呼び出した時の振る舞いが決まる

```java
class A {
  void print() {
    System.out.println("A");
  }
}

class B extends A {
  void print() {
    System.out.println("B");
  }
  void printB() {
    System.out.println("BBBBB");
  }
}

class Main {
  public static void main(String[] args) {
    A a = new B(); // 変数の型はAだが、実態はB。コンパイル時にはAと解釈されるが、実行の振る舞いはB。
    a.print(); // 動的バインディングによって、実態であるBの振る舞いをするので、「B」と出力
    a.printB(); // 静的バインディングによって、コンパイル時はAと解釈されるので、Aに含まれていないprintBメソッドは実行不可
  }
}
```





## インターフェース

実装と外部仕様を分離するための仕組み

クラスが「モノ」であるのに対し、インターフェースは「外部から見た仕様」を表現
→「動詞 + able」といった名前をつけることが多い
ex. ダウンロード可能なもの（外部仕様）←電子書籍（モノ）

- コンパイルされるとクラスファイルになる
- クラスと同様に変数の型として宣言可能
  - 戻り値や引数にも指定可能
- インターフェースは1つのクラスに複数実装可能
  - クラスの継承は単一継承
- アクセス修飾子は public のみ
- 抽象メソッドの修飾子は以下
  - public
  - abstract
  - strictfp ... 浮動小数点数の計算が実行環境に依存しないことを表す 
- インターフェースにおける抽象メソッドの修飾子は無条件で `public abstract` 
  - 抽象クラスには abstract を付与する必要あり
  - インターフェースには付与しないのが一般的

```java
interface インターフェース名 {
  ... 抽象メソッド ...
  ... デフォルトメソッド ...
  ... スタティックメソッド ...
  ... 定数 ...
}
```



## Object クラス

toString() メソッド ... 当該クラスの FQCN とハッシュ値が返される、system.out.println の引数にインスタンスを渡すと自動で呼び出される。

インターフェースでデフォルトメソッドとしてオーバーライドするとコンパイルエラーになる



## 同一性と等価性

### プリミティブ型

" == " によって同一性を判定する。
プリミティブ型においては、同一性と等価性は同義とみなされる。

### 参照型

" == " によって同一性を判定する。
参照型における同一性 → 「同一のインスタンスであること」

equals() メソッドによって等価性を判定する。

"==" ... 参照(アドレス)が同じか
equals() ... 値が同じか



## ジェネリクス

型を変数として扱うことができる概念

```java
// ジェネリクスを使ったBoxクラス
class Box<T> {
    // T型のデータを格納するフィールド
    private T value;

    // コンストラクタでT型のデータを受け取る
    public Box(T value) {
        this.value = value;
    }

    // T型のデータを返すメソッド
    public T getValue() {
        return value;
    }

    // T型のデータを設定するメソッド
    public void setValue(T value) {
        this.value = value;
    }
}

public class Main {
    public static void main(String[] args) {
        // String型のBoxインスタンスを作成
        Box<String> stringBox = new Box<>("Hello, Generics!");
        System.out.println("String Box: " + stringBox.getValue()); // 出力: Hello, Generics!

        // Integer型のBoxインスタンスを作成
        Box<Integer> integerBox = new Box<>(123);
        System.out.println("Integer Box: " + integerBox.getValue()); // 出力: 123
    }
}
```



## 関数型インターフェースとラムダ式

関数型インターフェース ... 抽象メソッドを1つだけ持ったインターフェース
ラムダ式 ... インターフェースを実装した具象クラスを作らずに、無名クラスとしてのインスタンスとして実装できるメソッド

ラムダ式内で扱う変数は、ラムダ式内外問わず、変更されてはならない

```java
@FunctionalInterface
interface Algorithm {
  // 自動で abstract public になる
  void performe(String name)
}

public class Main {
  public static void main(String args[]) {
    // 本来はクラスを宣言し、代入する必要が合ったが、ラムダ式により、記述量が減る
    // 無名クラスを作って、その中でメソッドを定義して、代入するという３ステップを省略している
    Algorithm algorithm = (name) -> {
      System.out.println(name)
    }
  }
}
```

頻繁に使われるものについては、Java SE8 からjava.util.function パッケージに追加されている。

### Consumer

引数を受け取って処理をし、何も返さない関数型インターフェース

```java
abstract void accept(T)
```

### Supplier

引数を受け取らずに処理をし、何かしらを返す関数型インターフェース

```java
abstract T get()
```

### Predicate

引数を受け取り、boolean を返す関数型インターフェース

```java
abstract boolean test(T)
```

### Function

引数を受け取り、任意の型の返り値を返す関数型インターフェース

```java
abstract R apply(T)
```

### メソッド参照

既存のメソッドをラムダ式のように代入するときに使う記法

```java
// クラスメソッドの場合
メソッド(クラス名::クラスメソッド);
// インスタンスメソッドの場合
メソッド(インスタンス名::インスタンスメソッド);
// 例
list.forEach(System.out::printlm);
```



## API

### Enum型

java.lang.Enumを継承したもの
Enumクラスのインスタンスとして扱われる

フィールド、コンストラクタ、メソッドを追加できる

```java
enum 列挙型名{
  列挙定数1,
  列挙定数2,
  (中略)
  列挙定数N
};
  
public enum CustomerType {
  // 列挙子
  GENERAL("一般会員"),
  GOLD("ゴールド会員"),
  PLATINUM("プラチナ会員"),
  DIAMOND("ダイヤモンド会員");
  
  // フィールド、上の一般会員とかの部分
  private final String cunstmerType;
  
  // コンストラクタ
  CustomerType(String customerType) {
    this.customerType = customerType;
  }
  
  // メソッド
  @Override
  public String toString() {
    return custmerType;
  }
}

CustomerType.GENERAL.toString // 一般会員(String型)
```

付与可能な修飾子は以下の2つ

- public ... 全てのクラスからアクセス可能
- strictfp ... 浮動小数点数の演算が実行環境に依存しないことを表す

Enumクラスが持つメソッド

- String name() ... 列挙子の名前を返す
- int ordinal() ... 列挙子の除数（記述した順に0から割り当てる）を返す
- String toString() ... 列挙子の文字列表現を返す
- static T[] values() ... この列挙型に定義された列挙子を配列で返す
- static T valueOf(Class<T>, String) ... 指定された名前に対応する列挙子を返す



## ComparableインターフェースとComparatorインターフェース

### Comparableインターフェース

並び替えをするためのインターフェース
IntegerやStringなどのクラスはこれを実装しているので、コレクションのsortメソッドの引数に、これらが要素となっている配列を渡すと自動で並び替える

toCompareメソッドを持つ ... 第一引数を前にしたかったら-1, 逆なら1, 同一なら0を返す

### Comparatorインターフェース

並び替えを実装するためのインターフェース
このインターフェースを自分で実装し、オリジナルの並び替えメソッドを作成する

compareメソッドを持つ

### sortメソッド

-1を受け取ると、順番はそのまま
1を受け取ると、順番を変える



## コレクション

### add(E element)

指定された要素をリストの最後に追加する

### add(int index, E element)

リスト内の指定された位置に指定された要素を挿入する

### clear()

リスト内のすべての要素を削除する

### contain(Object o)

指定の要素がリスト内に含まれる場合に true を返す

### get(int index)

リスト内の指定された位置にある要素を返す
存在しない番号を指定すると例外を返す( IndexOutOfBoundsException )

### remove(int index)

リスト内の指定された位置にある要素を削除する
実行後にコレクションの読み出しをすると例外をスローする

### remove(Object o)

指定された要素がリスト内に存在すれば、その最初のものを削除する
実行後にコレクションの読み出しをすると例外をスローする

### set(int index, E element)

リスト内の指定された位置にある要素を指定された要素に置き換える

### size()

リスト内の要素数を返す

 

## 配列

java.util.Arrays パッケージに属する、配列に関わるもの
Objectを継承しているので、List インターフェースを実装したコレクションとは全くの別物

### 定義方法

```java
// OK
int[] arr = {1, 2, 3};
int[][] arr = {{1, 2}, {1, 2}}
int[][] arr = new int[2][2];
// NG
int[][] arr = new int[][2]; // 要素数を定義しなかった箇所の後は要素数を定義できない、つまり[]の後に[2]としてはならない
```



### asList(T[] arrayT)

配列から固定長のリストを作成する
要素を増やしたり減らしたりすると例外をスローする

### compare(T[] t, U[] u)

引数で渡された2つの配列の要素を辞書順に並べたときの並び順を比較する
第一引数が先なら -1、第二引数が先なら 1、等しい場合は 0 を返す

### mismatch(T[] t, U[] u)

引数で渡された2つの配列の要素を先頭から順番に比較し、最初に一致しなかった要素の添字を戻す。
要素数が異なる場合：最初に一致しなかった要素の添字を戻す、要素が一致していれば存在しない要素を返す
すべての要素が一致する場合：-1 を返す



## 例外処理

### catch 句は複数書ける
ただし、到達不可能なコードを書いてはいけない
例外クラスもキャストが効くので、意図せず到達不可能なコードを生み出しがち

```java
try {
  System.out.println("try");
} catch (ExceptionA a) {
  System.out.println("a");
} catch (ExceptionB b) {
  System.out.println("b");
}
```

### catch 句で return しても finally 句が存在すれば、finally → catch の順に処理される

実行の流れ

1. `try`ブロック内で例外が発生。
2. 例外が`catch`ブロックで捕捉され、`return 1;`が実行される準備をする。
3. **`finally`ブロックが必ず実行**される。
4. `finally`実行後、`catch`の`return 1;`の値が呼び出し元に返される。

```java
try {
  System.out.println("try");
} catch (ExceptionA a) {
  System.out.println("catch");
} finally {
  System.out.println("finally");
}
// 出力結果 
// finally
// catch
```

ただし、`finally`内で別の`return`があると、そちらが優先される。
例えば次のようにすると`2`が返される

```java
public static int testMethod() {
    try {
        throw new Exception("Error");
    } catch (Exception e) {
        return 1;
    } finally {
        return 2; // こちらが最終的なreturn値になる
    }
}
```

### try-with-resources

AutoCloseable インターフェースを実装した入出力関連のクラスやDB関連のクラスを扱う時に使うtry-catch

- メリット
  - リソースの解放を自動で行ってくれる
  - リソース関連の例外処理を自動で行ってくれる

```java
public class Sample {
    public static void main(String[] args) {
        try (FileWriter fw = new FileWriter("/sample.txt")) {
            fw.write("sample");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 検査例外（チェック例外）と非検査例外（非チェック例外）

- 検査例外（チェック例外）
  - 例外処理を記述したかどうかをコンパイラが検査する例外
  - RuntimeExceptionとそのサブクラスを除いたすべての例外（ExceptionクラスとRuntimeException以外のサブクラス）
  - try-catch 文、または throws 句を書くことを強制される、しないとコンパイルエラー
  - 主にプログラムの外部環境に依存した問題（DBやNWなど）
  - 具体例
    - IOException
    - SQLException
    - FileNotFoundException
  - 設計意図
    - 開発者側で***予測不可能***なことが多いため、例外処理を強制する必要がないと判断される
- 非検査例外（非チェック例外）
  - 例外処理を記述したかどうかをコンパイラが検査しない例外
  - RuntimeExceptionとそのサブクラス
  - 主にプログラムのロジックや実装ミスで起こる
  - 具体例
    - NullPointerException
    - IndexOutOfBoundsException
    - IllegalArgumentException
  - 設計意図
    - 開発者側で***予測可能***なことが多いため、例外処理を強制する必要がないと判断される
    - コードの修正で対応すべき問題

### throws

- チェック例外が発生するコードでは、try-catchで例外処理をしていれば不要
- チェック例外が発生するコードでは、例外処理をしていない場合、throwsを書く
  - メソッドの呼び出し側でtry-catchの例外処理を書く必要がある



## モジュール

モジュール ... 複数のプログラムを何らかの機能に応じて1つにまとめたもの。
　　　　　　 複数のパッケージを１つにまとめ、公開するパッケージと非公開にするパッケージを分けて管理することができる。
モジュールシステム ... モジュールを管理するシステム
Javaにおけるモジュール ... パッケージの上位概念、複数のパッケージをさらに1つにまとめたもの

ライブラリ ... 機能として汎用性が高く、部品として他のプログラムから呼び出されることを前提としたソフトウェア
アプリケーション ... 特定の業務使用を実現するために開発されたソフトウェア

### モジュール導入前

1. ライブラリ内で特定のパッケージを別のパッケージに公開しようとすると、publicにせざるをえず、外部公開までしてしまう
2. クラスの検索時にクラスパス内に含まれるクラスを探すが、異なるJARファイルで同名のFQCNを持つクラスがあった場合、判別不可

### モジュールシステムの目的

- 上述した課題を解決できる
  - アクセス修飾子問題
    - パッケージ単位に公開範囲を決定できる
      - 全てのモジュールに対して外部公開する
      - 特定のモジュールに対してのみ外部公開する
      - 他のモジュールには公開しない（モジュール内のみ）
  - クラスパス問題
    - 異なるJARファイルで同名のFQCNを持つクラスがあった場合、エラーを返す
- モジュールシステム化は開発者が選ぶことができる
  - モジュール定義ファイルを作成する
- モジュール定義ファイルを含んだ1つのJARファイルが1つのモジュール

### モジュール定義ファイル

module-info.java

どのパッケージを公開するか、しないかを定義する。JARファイルのルートディレクトリ直下となる位置に配置する。

#### モジュール定義ファイルの書き方

以下のシチュエーションの場合

```
.
|- foo-lib
|    |- module-info.class
|    |- pro
|        |- sample
|            |- foo
|                |- api
|                |    |- StringUtil.class（外部公開したい）
|                |- internal
|                     |- Common.class（外部公開したくない）
|- hoge-app
     |- module-info.class
     |- pro
         |- sample
             |- hoge
                 |- Application.class（StringUtil.classを呼び出す）
```

```java
// foo-lib/module-info.class
module pro.sample.foo {
  exports pro.sample.foo.api; // 全公開
  exports pro.sample.foo.api to pro.sample.bar; // 特定のモジュールに公開
}

// hoge-app/module-info.class
module pro.sample.hoge {
  requires pro.sample.foo; // 必要なモジュールを設定する

  // fooモジュールが依存しているモジュールにもアクセスする
  // pro.sample.hogeをrequireしたモジュールではpro.sample.fooモジュールも使用可能になる
  requires transitive pro.sample.foo;
}
```

### 自動モジュール

JARファイルがモジュール定義ファイルを持っていなかったとしても、モジュールパス上に配置された場合は自動的にモジュールとして扱われる

包含される全てのパッケージがexportsされたものとみなされ、外部公開される
モジュールグラフ上の全てもモジュールをreqiresしたものとみなされる

### 無名モジュール

モジュール定義ファイルを持たないJARファイルがクラスパスから読み込まれた場合、無名モジュールとして扱われる
クラスパスによる読み込み処理が現時点でも残っていることを踏まえて、互換性維持のために作られたシステム

包含される全てのパッケージがexportsされたものとみなされ、外部公開される
モジュールグラフ上の全てもモジュールをreqiresしたものとみなされる
無名モジュールは名前を持たないため、モジュールシステム化されたモジュールからはアクセス不可
自動モジュールからはアクセス可能

