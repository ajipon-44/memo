# 良いコード/悪いコードで学ぶ設計入門

## 第1章

## 第2章

## 第3章

## 第4章 普遍の活用 -安定動作を構築する-

主作用 ... 引数を受け取り、関数内の処理をして、戻り値を返すこと
副作用 ... 主作用以外（関数外）の状態に影響を与えること。関数外の状態とは、インスタンス変数、グローバル変数、ファイルのI/O

大規模なアプリケーション、スレッドセーフが必要なアプリケーションでは、副作用を避けるために以下のような設計が望ましい。
インスタンス変数は書き換えず、新しいインスタンスを生成して返すパターン。

- メリット
  - スレッドセーフ
    - 副作用を避けることができる
  - 予測可能性が高まる
    - 冪等性が担保されるので、値が予測しやすくなる
- デメリット
  - 値の更新時に毎回新しいインスタンスを生成するので、頻繁にGCが起こり、負荷が高くなる
  - コードが複雑になる

```java
public class Sample {
  private final int value;

  public Sample(final int num) {
    if (num < 0) {
      throw new IllegalArgumentException("value must be non-negative");
    }
    this.value = num;
  }

  public Sample withValue(final int num) {
    return new Sample(num);
  }

  public int getValue() {
    return value;
  }
}
```



## 第5章 低凝集 -バラバラになったものたち-

凝集度 ... データとロジックの関係性の強さを表す指標。高凝集であるほど、変更容易性が高く、望ましい。

低凝集であることの弊害

- 重複コード
  - 開発者が前任者の実装漏れと勘違いし、同じコードを量産してしまう。
    - 結果として参照が複雑になる、変更箇所が多くなるなど保守性が低くなる
- 可読性の低下
  - コードの関係性や処理の流れを把握しづらくなる

### 初期化ロジックの分散

初期化のロジックが分散すると、1つの仕様変更で多くのコード変更が必要になる

#### 悪い例

以下の例では、初回ボーナスや月次ボーナスが複数の箇所に書かれていると、ポイントの数値が変わる仕様変更があった時、
多くの箇所のコードを書き換える必要がある。

```java
// 初期化ロジックが分散するクラス
public class Point {
  final int point;
  public Point(int point){
    this.point = point;
  }
}

// 標準会員の初回登録ボーナス
Point firstBonusPonint = new Point(3000);
nomalUser.updatePoint(firstBonusPonint);

// 標準会員の月次ボーナス
Point monthlyBonusPonint = new Point(1000);
nomalUser.updatePoint(monthlyBonusPonint);
```

#### 良い例

以下の例では、初回ボーナスや月次ボーナスが複数の箇所に書かれていると、ポイントの数値が変わる仕様変更があった時、
コードを1つ書き換えるだけでよい。

```java
// 初期化ロジックが分散するクラス
public class Point {
  private final int point;
  public Point(int point){
    this.point = point;
  }
  
  public static Point firstBonus() {
    return new Point(3000);
  }
  
  public static Point monthlyBonus() {
    return new Point(1000);
  }
}

// 標準会員の初回登録ボーナス
Point firstBonusPonint = new Point.firstBonus();
nomalUser.updatePoint(firstBonusPonint);

// 標準会員の月次ボーナス
Point monthlyBonusPonint = new Point.monthlyBonus();
nomalUser.updatePoint(monthlyBonusPonint);
```

### メソッドチェイン

#### デメテルの法則

・利用するオブジェクトの内部を知るべきではないという法則、メソッドチェインを利用するとこれに抵触する。
・「知らない人に話しかけるな」と要約されたりする。
・あるオブジェクトは親密なオブジェクト（友達）とだけやり取りすべきで、間接的なオブジェクト（友達の友達）とはやり取りすべきではない」という考え方
・記法の問題ではなく、変更の影響範囲を制御し、責任の所在を明確にするための設計原則

<img src="/Users/yanaikeigo/Library/Application Support/typora-user-images/スクリーンショット 2024-11-10 2.41.40.png" alt="スクリーンショット 2024-11-10 2.41.40" style="zoom:40%;" />

### 尋ねるな、命じろ（Tell, Don't ask）

Tell = オブジェクトに対してロジックの結果を聞く
Ask = オブジェクトに対してあれこれ聞いて手元でロジックを組み立てること

#### ダメな例

```javascript
if (user.type === 'admin') {
  user.getAdminWelcomeMessage()
} else {
  user.getUserWelcomeMessage()
}
```

#### 良い例

```javascript
user.getWelcomeMessage()
```

参考：https://zenn.dev/miya_tech/articles/2289a177cdf2ff



## 第6章 条件分岐 -迷宮化した噴気処理を解きほぐす技法-

### 単一責任選択の原則

ソフトウェアシステムが選択肢を提供しなければならないとき、そのシステムの中の1つのモジュールだけがその選択肢の全てを把握できるべきであるという原則。
端的にいうと、同じ条件式の条件分岐を複数書かず、1箇所にまとめるべき。

### インターフェースの作り方

1. 種類(クラス)ごとに切り替えたい機能を interface のメソッドとして定義する
2. 「なんの仲間であるか」を interface の名前にする
   1. 例：「ファイア」、「紫電」、「地獄の業火」→ 魔法の仲間 → interface の名前は Magic
3. 種類をクラス化する

### if 文の減らし方

#### ストラテジパターン

***デザインパターンの 1 種。条件分岐を削減し、ロジックを単純化するもの。***
interface を用いて、条件分岐を削減する。条件分岐はMapで行う。（単一責任選択の原則）

#### ポリシーパターン

***条件を表すクラスを複数作り、それらを1つに集約するパターン。***
同じ判定のロジックを使い回したり、条件の組み合わせをカスタマイズできたりする。

|                | 初級者                         | 中級者                 |
| -------------- | ------------------------------ | ---------------------- |
| 分岐           | 迷わず if 文や switch 文を使う | interface 設計を試みる |
| 分岐ごとの処理 | ロジックをベタ書きする         | クラス化を試みる       |

バリデーションの書き方

1. クラス内にバリデーション用のメソッドを作る
   1. メリット
      1. ロジックが完結
   2. デメリット
      1. 使い回しができない
      2. クラスが肥大化する
2. ポリシーパターンを適用する
   1. メリット
      1. 使い回しができる
      2. 単一責任
      3. クラスの肥大化を防ぐことができる
   2. デメリット
      1. システム構成が複雑になる
3. バリューオブジェクトを使い、新しいクラスにバリデーション用のメソッドを作成する
   1. メリット
      1. 使い回しができる
      2. 状態とロジックをまとめることで、高凝集になる
      3. ポリシーパターンよりは簡潔
   2. デメリット
      1. 場合によってはクラスが肥大化する
      2. クラス内にロジックを書くよりは複雑



## 第7章 コレクション -ネストを解消する構造化技法-

標準ライブラリに含まれているメソッドを知らないと車輪の再発明や四角い車輪の再発明につながる
やりたいことがある時は、同じような機能のメソッドが標準ライブラリに存在しないかチェックする

```java
// 標準ライブラリのメソッドを使わない例
boolean hasPrisonKey = false;
// itemsはList<Item>型
for (Item each : items) {
  if (each.name.equals("牢屋の鍵")) {
    hasPrisonKey = true;
    break;
  }
}

// 標準ライブラリのメソッドを使う例
boolean hasPrisonKey = items.stream().anyMatch(item -> item.name.equals("牢屋の鍵"));
```

### 早期 continue で条件分岐のネストを解消する

continue ... 条件を満たさない場合に、continue で次のループ処理に移る


### 早期 break もネスト解消に役立つ

break ... 処理を中断し、ループから抜け出す

### コレクションの低凝集を解決する

ファーストクラスコレクション ... コレクションに関するロジックをカプセル化する設計パターン。コレクション型インスタンス変数とそれを不正から守り、正しく動作させるメソッドを持つ。

```java
// ファーストクラスコレクションの例
class Party {
  private final List<Member> members;
  
  Party() {
    members = new ArrayList<Member>();
  }
  
  Party(List<Member> members) {
    this.members = members;
  }
  
  void add(final Member newMember) {
    List<Member> adding = new ArrayList<Member>(members);
    adding.add(newMember);
    return new Party(adding);
  }
  
  // メンバーを返す、ただし返した先で変更はできない
  List<Member> members(){
    return members.unmodifiableList();
  }
}
```



## 第8章 密結合 -絡まって解きほぐせない構造-

密結合 ... モジュール間の依存度合を表す指標、これが強いと変更が難しいシステムになってしまう

下手なロジックの使い回しをすると、1つの変更が使い回していたすべてのロジックに影響を与える

### DRY 原則

繰り返しを避けろという原則
これはロジックの使い回しを避けて、重複コードを減らせという意味ではない
なぜなら、ロジックの使い回しは上述のように、依存度の高いコードを生み出し、変更容易性を下げるから。

*** DRYにすべきは概念の単位（e.g. ECサイトであれば、「通常割引」、「夏季特別割引」、「気になる商品」etc.）***
***概念や責務が同じであれば共通化、そうでなければ重複ロジックだとしても別個に定義すべき***

### 継承とコンポジションの使い分け

- 継承
  - extendsを使う
  - 「is-a」関係（e.g. 犬は動物である）が成り立つ場合
- コンポジション
  - クラス内のインスタンス変数として、別のクラスを扱う
  - 「has-a」関係（e.g. タイヤは車に含まれる）が成り立つ場合

### 設定より規約

***開発者が指定すべきはアプリケーションの慣習に従わないものだけという考え方***

Javaの場合、アクセス修飾子にpublic, protected, デフォルト（何も書かない, package private）, privateが存在する。
設定より規約の考え方をすると、デフォルトでは package の中でのみ private であるべき、そうでないなら指定するということになる。
これに加え、不要な参照を避けるためにも基本的には package private （デフォルトのアクセス修飾子）を使用するべき。

### スマートUI（利口なUI）

フロントエンドに表示機能だけでなく、表示以外の機能（データフェッチや計算ロジック、分岐ロジック）などが混在するUI

責務の分離ができていないことをなんでもできるUIと皮肉った言葉

### 密結合を防ぐには

単一責任の原則を守ること

言語により誤差はあるが、単一責任の原則を守っているコードは1つのクラスは多くて200行、大体100行程度になる



## 第9章 設計の健全性を損なうさまざまな悪魔たち

### デッドコード

以下のように実行されることのないコードのこと、到達不可能なコードとも言う

```java
if(level > 99) return;
if(level == 100) { ... }
```

これを放置すると以下のようなデメリットがある

- 可読性が下がる
  - なぜこのコードが存在するのかなど無駄な考えを引き起こす
- バグの発生要因になる
  - 未来の変更でそのコードに到達できてしまうと、仕様通りに動かないという現象が発生する

### YAGNI 原則

You don't going to need it の略（必要ないでしょう）
必要なコードは必要なときに追加しようということ

予測して作ったといえば聞こえはいいが、以下のようなデメリットがある

- 無駄な仕事をすることになる可能性
  - 未来の仕様変更などが予測通りに行われるとは限らないので。
- 可読性の低下
  - デッドコードを書いているようなものなので。

### null 安全

null が原因で起こる NullPointerException など null が原因のエラーを防ぐための設計

- null を渡さない（代入しない）
- null を返さない（return null としない）

Kotlin はデフォルトで null 非許容型であり、null を渡すとコンパイルエラーになる

null 安全の必要性
null 判定の増加によってもたらされる可読性、保守性の低下によるエラーの回避

対策
何も所持していない状態という状態を Empty などの定数で表現する

```java
class Equipment {
  static final Equipment EMPTY = new Equipment("装備なし", 0, 0, 0);
  
  final String name;
  final int price;
  final int defence;
  final int magicDefence;
}
```



## 第10章 名前設計 -あるべき構造を見破る名前-

目的駆動名前設計 ... ソフトウェアで達成したい目的をベースに名前を設計すること

大雑把な命名はいろいろなユースケースと結びついてしまうので、あらゆる実装を引き付けてしまう。
結果、神クラスなどが出来上がり、可読性や保守性の低下に繋がる。

***ユースケースごとにクラスを分けるべき(分け方は6章、8章などを参考)***

### 名前設計で重要なポイント
これを守ることで、可読性の向上や、高凝集疎結合な設計が可能になる

#### 可能な限り具体的で、意味範囲が狭い、特化した名前

「会社の事業的にどういう目的を達成したいのかあ」を名前にする

メリット

- 名前とは無関係なロジックを排除しやすい
- クラスが小さくなる
- 関係するクラスの個数が少なくなり、結合度が低減する
- 関係するクラスが少ないので、仕様変更時に影響範囲が小さくなる
- どこを変更すれば良いか探しやすい
- 開発生産性が向上する

#### 存在ベースでなく、目的ベースで名前を考える

| 存在ベース | 目的ベース                                             |
| ---------- | ------------------------------------------------------ |
| 住所       | 配送元、配送先、勤務先、本籍地                         |
| 金額       | 請求金額、消費税がく、延滞補償料、キャンペーン割引料金 |
| ユーザ     | アカウント、個人プロフィール、職務経歴                 |
| ユーザ名   | アカウント名、表示名、本名、法人名                     |
| 商品       | 入庫品、予約品、注文品、配送品                         |

#### どんな関心ごとがあるか分析する

登場人物や事柄、関係性を整理し、分析する

#### 声に出して話してみる

頭の中で思っていることはぼんやりしていることが多い

名前やどんな目的を達成したいのか、どう使われるか、何と関係するかなど背景や目的をチームですり合わせる

#### 利用規約を読んでみる

利用規約にはサービスの取り扱いやルールが厳密に書かれているので、仕様の把握や名前設計の参考になる

#### 違う名前に置き換えられないか検討する

#### 疎結合高凝集になっているか点検する

関連付けされているクラスの個数を確認する

### 形容詞で区別が必要なものはクラス化を考える

***新品***価格と***中古***価格、***平日***料金と***休日***料金など

 ### コンテキストで分ける

Carクラスがあり、配送と販売のコンテキストがあったとき

配送パッケージの Car クラスと販売パッケージの Car クラスに分けると疎結合になる

### 英語で考える

責務の確認には英語で確認すると良い

#### 良い例

メソッド呼び出しで英語の文が成り立つ

```java
class Member {
  static boolean isHungry(Member member){
    ...
}
// Member.isHungry
```

#### 悪い例

メソッド呼び出しで英語の文が成り立たない、つまり責務ではないメソッドの可能性がある

```java
class Common {
  static boolean isHungry(Member member){
    ...
}
// Common.isHungry
```



## 第11章 コメント -保守性と変更の正確性を高める書き方-

### コメントのルール

| ルール                                                       | 理由                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ロジック変更時、同時に必ずコメントも変更すること             | コメントを変更しないと、ロジックと乖離した「退化コメント」が生じ、<br />読み手が混乱する |
| ロジックの内容をなぞるだけのコメントをしないこと             | あまり可読性に貢献しない上、コメントのメンテナンスコストが高まるため。<br />退化コメントも発生しやすい。 |
| 可読性の悪いロジックを細く説明するようなコメントをしないこと。<br />（代わりにロジックの可読性を高めるべき。） | コメントのメンテナンスコストが高まるため。<br />退化コメントも発生しやすい。 |
| ロジックの意図や仕様変更時の注意点をコメントすること。       | 保守や仕様変更時の助けになる。                               |

### ドキュメントコメント

フォーマットに従ってコメントを記述すると、API ドキュメントの生成や IDE でポップアップが表示される。

Java ... Javadoc
Ruby ... YARD

Javadoc の例

```java
class Money {
  // 中略
  
  /**
   * 金額を計算する
   *
   * @param other 加算する金額
   * @return 加算後の金額
   * @throws IllegalArgumentException 通貨単位が異なる場合スロー
   */
  Money add(final Money other) { ... }
}
```



## 第12章 メソッド(関数) -良きクラスには良きメソッドあり-

以下、メソッドを作る上で意識すること

### 必ず自身のインスタンス変数を使うこと

### 不変をベースに予期せぬ動作を防ぐ関数にすること

### 尋ねるな、命じろ

### コマンド・クエリ分離（CQS）

メソッドはコマンド（＝変更）またはクエリ（＝問い合わせ）のどちらか一方だけ行うよう設計するという考え方。
ただし、同時にしかできないこともあるので、例外的なもの以外は避けるようにするくらいの温度感。

| メソッド種別   | 説明                         |
| -------------- | ---------------------------- |
| コマンド       | 状態を変更する               |
| クエリ         | 状態を返す                   |
| モディファイア | コマンドとクエリを同時に行う |

```java
// モディファイア
modifire() {
  point += 10;
  return point;
}

// コマンド
command() {
  point += 10;
}
// クエリ
query() {
  return point;
}
```

### 引数

- 引数は不変にすること
  - 変更すると意味が変わり、推測が困難になる
- フラグ引数は使わない
  - ロジックを読む必要が出てくるため
  - ストラテジパターンなどを利用して、挙動を変える
- null を渡さない
  - ぬるぽの原因になる
  - null チェックによるコードの複雑化を防ぐ
  - null に意味を持たせず、空なら空という状態を作る
- 出力引数は使わない
- 引数は可能な限り少なくする

### 戻り値

- 型を使って意図を持たせる
  - 値段を int 型で返しても分かりづらい。バリューオブジェクトにして、新しいインスタンスを生成して返すべき。
- null を返さない
- エラーは戻り値で返さない、例外をスローする
  - エラーなら -1 を返すなどとすると、仕様を知らない人は何をしているのか分からなくなる
  - エラーなら例外を投げるべき



## 第13章 モデリング -クラス設計の土台-

システム ... ***目的達成のための手段、効率化するためのもの***（e.g. 移動手段 ... 二足歩行→馬車→自動車→飛行機など）
モデル ... ***特定の目的を達成するために最低限考慮が必要な要素***を備えたシステムの一部（e.g. 自動車 ... タイヤ、車体など）

### 具体例

#### 目的のわからない商品モデル
ID、商品名、原価、売値、製造年月日、製造メーカー、耐用年数、対応通信規格、構成部品 etc.

#### 目的ごとに定義した商品モデル

注文時の商品モデル
ID、商品名、売値、在庫数

配送時の商品モデル
ID、サイズ、重量

### 情報システム

Github の例

ログイン認証→アカウント（個人、法人）
生年月日などパーソナリティのあるもの→プロフィール

***現実世界の物理的な存在と、情報システム上のモデルは 1:1 になるとは限らない。***

### モデルの見直し方

- そのモデルが達成しようとしている目的を全て洗い出す
- 目的それぞれ特化したモデリングをし直す
- 目的駆動名前設計に基づき、モデルに命名する
- モデルに目的外の要素が入り込んでいる場合、さらに見直す



## 第14章 リファクタリング -既存コードを成長に導く技-

### ロジックをベタ書きしない

以下のように書いてあっても目的がわかりづらい

```java
if (consumer.possessionPoint < comic.currentPurchasePorint.amount)
```

クラスにメソッドを用意する

```java
/**
 * @params comic 購入対象のwebコミック
 * @return 所持ポイントが不足している場合、true
 */
boolean isShortOfPoint(Comic comic) { ... }
```

### 機能追加とリファクタリングは同時にやらない

### スモールステップで行う



## 第15章 設計の意義と設計への向き合い方

## 第16章 設計を妨げるプロセスとの戦い

### パフォーマンスについて

パフォーマンスを気にするのは違和感を感じたり、計測したりしてから
パフォーマンスを気にして、あらかじめ最適化されたコードを書くのは***早すぎる最適化***というアンチパターン

そんなことより変更容易性と可読性の担保されたコードを書くべき

### コードレビュー

敬意と礼儀を持つこと

| すべきこと             | 解説                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 能力と善意を想定する   | 開発者の十分な能力と善意を想定する。ミスは情報不足に起因するものと考える。 |
| 会って話し合う         | レビューツール上で話がまとまらなければ、会って意見交換する。 |
| 理由を説明する         | なぜ間違っているのか、どういう変更が正しいか説明する。       |
| 理由を聞く             | 相手の意図が不明瞭な場合は理由を聞く。後々に仕様や変更意図が残ることにもなるので良い。 |
| 終わりを見つける       | 完璧を求めて徹底的なレビューをするとレビューされる側が疲弊する。<br />「絶対に間違いはない」ではなく、「良さそうです」を目指す。 |
| 適度な時間内に返信する | 24時間以内、そうでなければいつ返信できるかを示す。           |
| ポジティブに述べる     | 「欠点を見つける」という気持ちではなく、「ポジティブな点」を見つけるためにレビューする。 |

| いけないこと               | 解説                                           |
| -------------------------- | ---------------------------------------------- |
| 自転車置き場の議論をしない | どちらでもいいことで勝ち負けを決めようとしない |

#### 悪い例

ここで〇〇メソッドは使わないでください。パフォーマンスが悪いです。こういう実装は何もいいことがありません。

#### 良い例

動作しますし、十分いい変更です。ただ、パフォーマンスをもう少し改善したいです。〇〇メソッドでも実装できますが、⬜︎⬜︎メソッドの方が実行速度が有利です。

### 一気に変更を加えようとしない

設計の変更の間、他の仕事ができなくなる。
なのであくまで***「変更箇所が多い、仕様変更の頻度が高い箇所」***に絞って効果的な設計をする。

