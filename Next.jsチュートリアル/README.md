# Next.js チュートリアル

## Chapter 3 - Optimizing Fonts and Images -

### フォントの最適化

#### フォントの種類

フォールバックフォント ... HTML や OS に標準で備わっているフォント（h1 や bold など）。別名システムフォント。
カスタムフォント ... CSS などで装飾されたフォント。サーバや外部リソースから取得する。

#### ブラウザの挙動

1. ページを読み込み、システムフォントで出力する。
2. CSS やフォントファイルをロードする（ここでファイル取得や読み込みのための時間がかかってしまう）。
3. 装飾されたページが表示される。

#### レイアウトシフト

システムフォントからカスタムフォントに切り替わった時に、文字の大きさや文字同士の間隔の差異によって起こるページのずれ

#### CLS（累積レイアウトシフト）

Google のサイト評価の指標の 1 つ。これが大きいと、ページの表示に時間がかかると判定される。

#### next/font

ビルド時にフォントに関するロードを行う
よって、ユーザが使う時に、オーバーヘッドが生じない

### 画像の最適化

#### 画像の最適化をすべき理由

画像の読み込みには一定の時間がかかるので、最適化の有無によって SEO や UX に大きく影響する

#### 従来の画像の最適化

以下の項目は従来は手動で最適化を行なっていた。

1. **レスポンシブ画像の確保**
   画像が異なる画面サイズに対応できるようにする。
2. **異なるデバイス用の画像サイズ指定**
   モバイルデバイスとデスクトップで異なるサイズの画像を使い分ける。
3. **レイアウトシフトの防止**
   画像が読み込まれる際に、ページが動かないようにする。
4. **遅延読み込み（Lazy loading）の実装**
   ユーザーが実際に画像を見るまで、画像を読み込まないようにする。

#### Image コンポーネント

HTML の img タグの拡張版で手動で行っていた項目を自動で行う

1. **最新フォーマットでの提供**

   WebP や AVIF といった、ブラウザがサポートしている最新の画像フォーマットを使用して、画像サイズを圧縮する。
   これにより、読み込み速度がさらに向上する。
   ブラウザがこれらのフォーマットをサポートしていない場合は、他の形式の画像を使う。

2. **異なるデバイス用の画像サイズ指定**
   デバイスを検知して、自動で画像をリサイズする。

3. **レイアウトシフトの防止**
   （元の画像サイズや CSS などから算出したサイズをもとに）画像のサイズ表示領域をあらかじめ確保しておくことによって、画像が表示されたときに、ページのレイアウトが崩れることを防ぐ。
   よって、`width`と`height`の属性を指定することが必須。

4. **遅延読み込み（Lazy loading）の実装**
   デフォルトで遅延読み込みを行うので、パフォーマンスが向上する。

## Chapter 4 - Creating Layouts and Pages -

### ルーティングの方法

app ディレクトリ配下にディレクトリを作り、page.tsx ファイルを設置する。
例えば、app/dashboard/page.tsx にアクセスする URL は https://localhost:8080/dashboard になる

### 特別なファイル

#### layout.tsx

複数のファイルで共有される UI を表すファイル
layout.tsx が存在する同階層とその下の階層のファイルを Children として受け取る

### page.tsx

## Chapter 5 - Navigating Between Pages -

### Link コンポーネント

HTML の a タグの代わりに Link コンポーネントを使用する。
クライアントサイドナビゲーションによってページ遷移する。

#### クライアントサイドナビゲーション

- Link コンポーネントを使用する
- 必要な JS ファイルやデータだけを取得し、ページの変更箇所だけを更新するので、高速
  - ネットワーク通信量が少ない
  - ページ全体のロードをしないので動作がスムーズ
- JavaScript を利用してページ遷移を行う

#### サーバサイドナビゲーション

- a タグを使用する
- ページ遷移時、サーバ側にリクエストを送信する
- レンダリング済みのページが返ってくるので、それを表示する
  - ページ全体が再読み込みされるため、少し遅く感じる

#### コード分割

Next.js ではビルド時にページ単位で固有の JS ファイルにバンドルを行う。
このようにすることで、大規模なアプリだとしても初回ロードに時間がかかりすぎない

#### プリフェッチング

ユーザのスクロールなどにより、リンクが画面内に見える位置になった、または近づいた場合にリンク先のページをバックグラウンドで取得する仕組み
Intersection Observer API を活用して画面の動きを監視している
取得されたファイルはブラウザや Next.js のキャッシュに保存され、リンクがクリックされると取得される。

#### まとめ

1. ビルドするとページ単位でコード分割されて JS ファイルにバンドルされる
2. 初回ロード時には表示されるページしかフェッチされない
3. ユーザがスクロールし、リンクが近くなると、バックグラウンドでリンク先のページをプリフェッチし、キャッシュに保存する
4. ユーザがリンクを押下すると、キャッシュからページを取得し、表示する

### アクティブリンク

アクティブリンク ... タブに複数の項目がある場合などに、現在アクセスしている項目を分かりやすく色付けするもの

usePathname() ... 現在の URL を返す hooks。https://example.com/about にアクセスすると /about を返す

#### Client Component

- 動作
  - ブラウザ上で実行されるコンポーネント
- 特徴
  - JS を利用してインタラクティブな要素（ボタンのクリックやフォーム入力など）を実現する
  - 状態管理やイベントハンドラに対応（useState などの hooks、window オブジェクトなど）
  - 必要に応じてサーバからデータを取得し、クライアントサイドでデータを処理

```jsx
"use client";
import { useState } from "react";

export default function Counter() {
  const [count, setCount] = useState(0);

  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>;
}
```

#### Server Component

- 動作
  - サーバ上で実行されるコンポーネント
- 特徴
  - サーバ上で JS を実行し、静的な HTML を生成
  - 高速な初期レンダリングと SEO に適している
  - 状態管理やブラウザ固有の API（例: `window` や `useEffect`）は使用できない。

```jsx
export default async function UserList() {
  const res = await fetch("https://api.example.com/users");
  const users = await res.json();

  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

Server コンポーネントによって軽量で効率的な初期レンダリングを提供し、必要な部分だけを Client コンポーネントでインタラクティブにするのがベストプラクティス

## Chapter 6 - Setting Up Your Database -

省略

## Chapter 7 - Fetching Data -

Server Component によって、サーバ上から DB に問い合わせをできるため、ロジックを持つことができ、結果だけをクライアント側に送ることができる

### 並列データフェッチ

Promise.all や Promise.allSettled を使うことで、全てのプロミスを同時に開始することができる

```javascript
const data = await Promise.all([
  invoiceCountPromise,
  customerCountPromise,
  invoiceStatusPromise,
]);
```

メリット

- 各リクエストの完了を待たずにフェッチできるので、高速化が図れる
- ネイティブな JS なので、どんなライブラリにも対応できる

デメリットは次章で解説

## Chapter 8 - Static and Dynamic Rendering -

### Static Rendering

データのフェッチとレンダリングはビルド時とデータの再検証時に行われる
ユーザがアクセスするたびにキャッシュされた結果が表示される

#### メリット

- Web サイトの高速化
  - プリレンダリングされたコンテンツをキャッシュして配信する
- 負荷軽減
  - キャッシュされたデータを提供するので、ユーザのリクエストごとにコンテンツを生成する必要がない
- SEO 対策
  - プリレンダリングされたコンテンツは利用可能状態になっているため、検索エンジンのクローラーがインデックスしやすい

#### 使い所

静的なブログ記事や製品ページなど、データのない UI やユーザ間で変わらないページ

### Dynamic Rendering

リクエスト時に各ユーザに対して、サーバ上でコンテンツがレンダリングされる

#### メリット

- リアルタイム性
  - リアルタイム、または頻繁に更新されるデータを表示させることができる
- ユーザ固有のコンテンツ
  - パーソナライズされたコンテンツを提供できる
- リクエスト時の情報
  - Cookie や検索パラメータなどリクエスト時にしか分からない情報にアクセスできる

#### デメリット

- データの取得が遅い場合、全体のパフォーマンスがそれに引きづられる

## Chapter 9 - -

## Chapter 10 - -

## Chapter 11 - -

## Chapter 12 - -

## Chapter 13 - -

## Chapter 14 - -

## Chapter 15 - -

## Chapter 16 - -
